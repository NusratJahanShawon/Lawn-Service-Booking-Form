<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dynamic Booking Form</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 20px;
    }
    .form-container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px; padding: 40px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      width: 100%; max-width: 600px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .form-header { text-align: center; margin-bottom: 30px; }
    .form-header h1 { color: #333; margin-bottom: 10px; font-size: 2.2em; font-weight: 700; }
    .form-header p { color: #666; font-size: 1.02em; }
    .form-group { margin-bottom: 18px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #333; font-size: 1.02em; }
    .form-control {
      width: 100%; padding: 14px 16px; border: 2px solid #e0e0e0; border-radius: 12px; font-size: 16px;
      transition: all 0.2s ease; background: white;
    }
    .form-control:focus {
      outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); transform: translateY(-1px);
    }
    .form-control:hover { border-color: #b0b0b0; }
    select.form-control { cursor: pointer; }
    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;
      padding: 16px 28px; border-radius: 12px; font-size: 17px; font-weight: 600; cursor: pointer;
      transition: all 0.25s ease; width: 100%; margin-top: 8px;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 25px rgba(102, 126, 234, 0.25); }
    .btn:active { transform: translateY(0); }
    .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
    .loading { display: none; text-align: center; color: #667eea; font-weight: 600; margin: 16px 0; }
    .loading.show { display: block; }
    .spinner {
      display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #667eea;
      border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;
    }
    @keyframes spin { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
    .success-message, .error-message {
      padding: 12px; border-radius: 10px; margin: 12px 0; font-weight: 600; display: none; font-size: 0.98em;
    }
    .success-message { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .error-message { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

    @media (max-width: 768px) {
      .form-container { padding: 28px 18px; }
      .form-header h1 { font-size: 1.8em; }
    }
  </style>
</head>
<body>
<div class="form-container">
  <div class="form-header">
    <h1>Lawn Service Booking Form</h1>
    <p>Contractor: choose a schedule, review property/date, adjust if needed, and submit to confirm.</p>
  </div>

  <div class="loading" id="loadingIndicator">
    <span class="spinner"></span> Loading form data...
  </div>

  <div class="success-message" id="successMessage"></div>
  <div class="error-message" id="errorMessage"></div>

  <form id="bookingForm" novalidate>
    <div class="form-group">
      <label for="contractorName">Contractor Name *</label>
      <select id="contractorName" name="contractorName" class="form-control" required>
        <option value="">Choose a contractor...</option>
      </select>
    </div>

    <div class="form-group">
      <label for="companyName">Company Name</label>
      <input type="text" id="companyName" name="companyName" class="form-control" readonly />
    </div>

    <div class="form-group">
      <label for="scheduleId">Available Schedules</label>
      <select id="scheduleId" name="scheduleId" class="form-control">
        <option value="">Choose a schedule...</option>
      </select>
    </div>



    <!-- Hidden but programmatically filled -->
    <div class="form-group" style="display:none;">
      <input type="hidden" id="propertyId" name="propertyId" />
      <label for="propertyDisplay">Property</label>
      <input type="text" id="propertyDisplay" class="form-control" readonly />
    </div>
    <div class="form-group" style="display:none;">
      <label for="serviceDate">Schedule Service Date</label>
      <input type="date" id="serviceDate" name="serviceDate" class="form-control" readonly />
    </div>
    <div class="form-group" style="display:none;">
      <label for="serviceType">Service Type</label>
      <input type="text" id="serviceType" name="serviceType" class="form-control" readonly />
    </div>
    <div class="form-group" style="display:none;">
      <label for="assignedContractor">Assigned Contractor</label>
      <input type="text" id="assignedContractor" name="assignedContractor" class="form-control" readonly />
    </div>
    <div class="form-group" style="display:none;">
      <label for="statusSource">Status (source)</label>
      <input type="text" id="statusSource" class="form-control" readonly />
    </div>

    <!-- Visible user selections -->
    <div class="form-group">
      <label for="property">Select Property *</label>
      <select id="property" name="property" class="form-control" required>
        <option value="">Choose a property...</option>
      </select>
    </div>

    <div class="form-group">
      <label for="service">Select Service *</label>
      <select id="service" name="service" class="form-control" required>
        <option value="">Choose a service...</option>
      </select>
    </div>

    <div class="form-group">
      <label for="bookingDate">Preferred Date *</label>
      <input type="date" id="bookingDate" name="bookingDate" class="form-control" required />
    </div>

    <div class="form-group">
      <label for="status">Status *</label>
      <select id="status" name="status" class="form-control" required>
        <option value="">Choose status...</option>
        <option value="Scheduled">Scheduled</option>
        <option value="On Process">On Process</option>
        <option value="Cancelled">Cancelled</option>
      </select>
    </div>

    <div class="form-group">
      <label for="timeSlot">Preferred Time</label>
      <select id="timeSlot" name="timeSlot" class="form-control">
        <option value="">Choose a time slot...</option>
        <option value="09:00">09:00 AM</option>
        <option value="10:00">10:00 AM</option>
        <option value="11:00">11:00 AM</option>
        <option value="12:00">12:00 PM</option>
        <option value="13:00">01:00 PM</option>
        <option value="14:00">02:00 PM</option>
        <option value="15:00">03:00 PM</option>
        <option value="16:00">04:00 PM</option>
        <option value="17:00">05:00 PM</option>
      </select>
    </div>

    <div class="form-group">
      <label for="notes">Additional Notes</label>
      <textarea id="notes" name="notes" class="form-control" rows="4" placeholder="Any special requirements or notes..."></textarea>
    </div>

    <button type="submit" class="btn" id="submitBtn">📅 Submit Booking Request</button>
  </form>
</div>

<script>
/* ===================== Config ===================== */
const CONFIG = {
  // n8n webhook where the booking payload goes first
  submitEndpoint: 'https://primary-production-f6af0.up.railway.app/webhook-test/formsub',

  // --- NocoDB: USE TWO ENDPOINTS ---
  // 1) schedulesListEndpoint: the table/view you LIST schedules from (read)
  schedulesListEndpoint: 'https://nocodb-production-0a33.up.railway.app/api/v2/tables/moose8vh2e5j4nt/records',

  // 2) bookingsCreateEndpoint: the table you CREATE new bookings in (write)
  // >>> CHANGE THIS to your BOOKINGS table records URL <<<
  bookingsCreateEndpoint: 'https://nocodb-production-0a33.up.railway.app/api/v2/tables/mjc7wycwsr6fo60/records',

  // 3) contractorsListEndpoint: the table you LIST contractors from (read)
  contractorsListEndpoint: 'https://nocodb-production-0a33.up.railway.app/api/v2/tables/mp91f5wrx1r8o2x/records',

  // API token that has read on schedules + create on bookings
  nocodbToken: 'N9Nm6rltNDVLcQQQFCo9PZZDv74_6hBIaBp53i6j',

  // If you want to also create a REAL LINK from Booking -> Schedule (optional)
  linkSchedule: {
    enabled: true,              // set true if you have a Link column in Bookings
    bookingsTableId: 'mjc7wycwsr6fo60',
    linkFieldId: 'cud8yu712yq4ef2' // the Link-to-Another-Record field id in Bookings that points to Schedules
  },

     // Optional API key for your n8n webhook (Bearer); leave empty if not needed
   apiKey: '',
 };
 
 // Function to help find exact field names in your NocoDB table
 async function getNocoDBTableFields() {
   try {
     const response = await fetch(CONFIG.bookingsCreateEndpoint.replace('/records', ''), {
       method: 'GET',
       headers: {
         'accept': 'application/json',
         'xc-token': CONFIG.nocodbToken
       }
     });
     
     if (response.ok) {
       const data = await response.json();
       console.log('=== YOUR NOCODB TABLE FIELDS ===');
       console.log('Available columns in your Bookings table:');
       if (data.columns) {
         data.columns.forEach(col => {
           console.log(`- "${col.title}" (ID: ${col.id})`);
         });
       }
     }
   } catch (error) {
     console.log('Could not fetch table structure:', error);
   }
 }

/* ===================== Boot ===================== */
document.addEventListener('DOMContentLoaded', function () {
  const scheduleSelect = document.getElementById('scheduleId');
  if (scheduleSelect) {
    scheduleSelect.addEventListener('change', function () {
      applyScheduleSelection(this.value);
    });
  }
  
  const contractorSelect = document.getElementById('contractorName');
  if (contractorSelect) {
    contractorSelect.addEventListener('change', function () {
      applyContractorSelection(this.value);
    });
  }
  
   loadSchedulesFromNocoDB();
   loadContractorsFromNocoDB();
   
   // Get the exact field names from your NocoDB table
   getNocoDBTableFields();
});

/* In-memory schedule map */
let scheduleRowsById = new Map();
/* In-memory contractor map */
let contractorRowsByName = new Map();

/* ===================== Helpers ===================== */
function isBlank(v) { return v == null || (typeof v === 'string' && v.trim() === ''); }

function showLoading(show, message = 'Loading form data...') {
  const loader = document.getElementById('loadingIndicator');
  if (show) { loader.textContent = ' '; loader.innerHTML = '<span class="spinner"></span>' + message; loader.classList.add('show'); }
  else { loader.classList.remove('show'); }
}
function showSuccess(message) {
  const successDiv = document.getElementById('successMessage');
  successDiv.textContent = message;
  successDiv.style.display = 'block';
  setTimeout(() => { successDiv.style.display = 'none'; }, 5000);
}
function showError(message) {
  const errorDiv = document.getElementById('errorMessage');
  errorDiv.textContent = message;
  errorDiv.style.display = 'block';
  setTimeout(() => { errorDiv.style.display = 'none'; }, 8000);
}
function clearMessages() {
  document.getElementById('successMessage').style.display = 'none';
  document.getElementById('errorMessage').style.display = 'none';
}

function getField(row, keys) {
  for (const key of keys) if (Object.prototype.hasOwnProperty.call(row, key) && row[key] != null && row[key] !== '') return row[key];
  const normMap = {};
  for (const k in row) normMap[String(k).toLowerCase().replace(/\s|_/g, '')] = row[k];
  for (const key of keys) {
    const nk = String(key).toLowerCase().replace(/\s|_/g, '');
    if (normMap[nk] != null && normMap[nk] !== '') return normMap[nk];
  }
  return null;
}

function resolvePropertyName(row) {
  const ex = row._expand || row._EXPAND || null;
  const keys = ['Property','Property_ID','property_id','property','PropertyId'];
  let linked = null;
  if (ex) for (const k of keys) { if (ex[k]) { linked = ex[k]; break; } if (ex[String(k).replace(/\s/g,'_')]) { linked = ex[String(k).replace(/\s/g,'_')]; break; } }
  if (!linked && row['Property'] && typeof row['Property'] === 'object') linked = row['Property'];
  if (!linked && row.Property_ID && typeof row.Property_ID === 'object') linked = row.Property_ID;

  const candidates = ['Property Name','Property_Name','name','Name','title','Title','displayValue','label'];
  if (linked) {
    const first = Array.isArray(linked) ? linked[0] : linked;
    if (first && typeof first === 'object') {
      for (const c of candidates) {
        if (first[c]) return String(first[c]);
        const nk = String(c).toLowerCase().replace(/\s|_/g,'');
        for (const fk in first) if (String(fk).toLowerCase().replace(/\s|_/g,'') === nk) return String(first[fk]);
      }
    } else if (first != null) return String(first);
  }
  return null;
}

function resolvePropertyDisplay(row) {
  const ex = row._expand || row._EXPAND || null;
  const keys = ['Followup','followup','Follow Up','Follow_Up'];
  let linked = null;
  if (ex) for (const k of keys) { if (ex[k]) { linked = ex[k]; break; } }
  if (!linked && row.Followup && typeof row.Followup === 'object') linked = row.Followup;
  const candidates = ['Full Address','Property Address','Property Name','Address','FullAddress','PropertyAddress','Property_Name','name','Name','title','Title','displayValue','label'];
  if (linked) {
    const first = Array.isArray(linked) ? linked[0] : linked;
    if (first && typeof first === 'object') {
      for (const c of candidates) {
        if (first[c] != null && first[c] !== '') return String(first[c]);
        const nk = String(c).toLowerCase().replace(/\s|_/g,'');
        for (const fk in first) if (String(fk).toLowerCase().replace(/\s|_/g,'') === nk && first[fk] != null && first[fk] !== '') return String(first[fk]);
      }
    } else if (first != null) return String(first);
  }
  return null;
}

function getDisplayString(value) {
  if (value == null) return '';
  if (['string','number','boolean'].includes(typeof value)) return String(value);
  if (Array.isArray(value)) return getDisplayString(value[0]);
  if (typeof value === 'object') {
    const candidates = ['Address','Full Address','Property Address','Property Name','FullAddress','PropertyAddress','Property_Name','name','Name','title','Title','displayValue','label'];
    for (const c of candidates) {
      if (value[c] != null && value[c] !== '') return String(value[c]);
      const nk = String(c).toLowerCase().replace(/\s|_/g,'');
      for (const k in value) if (String(k).toLowerCase().replace(/\s|_/g,'') === nk && value[k] != null && value[k] !== '') return String(value[k]);
    }
  }
  try { return JSON.stringify(value); } catch { return String(value); }
}

// Try to resolve a plausible date from the row and any expanded linked rows
function resolveAnyDate(row) {
  if (!row || typeof row !== 'object') return null;
  const primary = getField(row, [
    'Schedule Service Date','Schedule Service Datem','Schedule_Service_Date','Service Date','service date','service_date',
    'Work_Date','work date','upcoming_date','upcoming date','date','scheduled_date','scheduled date','booking_date','booking date'
  ]);
  if (primary) return primary;

  const ex = row._expand || row._EXPAND || {};
  const expandTargets = Object.values(ex);
  for (const target of expandTargets) {
    const first = Array.isArray(target) ? target[0] : target;
    if (first && typeof first === 'object') {
      const d = getField(first, [
        'Schedule Service Date','Schedule Service Datem','Schedule_Service_Date','Service Date','service date','service_date',
        'Work_Date','work date','upcoming_date','upcoming date','date','scheduled_date','scheduled date','booking_date','booking date'
      ]);
      if (d) return d;
    }
  }
  // Fallback: scan keys with "date" substring
  const tryObject = (o) => {
    for (const k in o) {
      if (!Object.prototype.hasOwnProperty.call(o,k)) continue;
      const v = o[k];
      if (/(^|_|\s)date(s)?($|_|\s)/i.test(k) || /date$/i.test(k)) {
        if (v != null && v !== '') return v;
      }
    }
    return null;
  };
  const fallback = tryObject(row);
  if (fallback) return fallback;
  for (const target of expandTargets) {
    const first = Array.isArray(target) ? target[0] : target;
    if (first && typeof first === 'object') {
      const fv = tryObject(first);
      if (fv) return fv;
    }
  }
  return null;
}

function parseFlexibleDate(input) {
  if (!input) return null;
  if (input instanceof Date) return isNaN(input.getTime()) ? null : input;
  const raw = String(input).trim().replace('T',' ').split(' ')[0];

  let m = raw.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
  if (m) {
    let d = parseInt(m[1],10), mo = parseInt(m[2],10), y = parseInt(m[3],10);
    if (y < 100) y += 2000;
    if (d>=1 && d<=31 && mo>=1 && mo<=12) {
      const dtDmy = new Date(Date.UTC(y, mo-1, d));
      if (!isNaN(dtDmy.getTime())) return dtDmy;
    }
    const dtMdy = new Date(Date.UTC(y, d-1, mo));
    if (!isNaN(dtMdy.getTime())) return dtMdy;
  }

  m = raw.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if (m) {
    const y = parseInt(m[1],10), mo = parseInt(m[2],10), d = parseInt(m[3],10);
    const dt = new Date(Date.UTC(y, mo-1, d));
    return isNaN(dt.getTime()) ? null : dt;
  }

  const dflt = new Date(raw);
  return isNaN(dflt.getTime()) ? null : dflt;
}
function toDateInputValue(dateString) {
  const d = parseFlexibleDate(dateString); if (!d) return '';
  const yyyy = d.getUTCFullYear();
  const mm = String(d.getUTCMonth()+1).padStart(2,'0');
  const dd = String(d.getUTCDate()).padStart(2,'0');
  return `${yyyy}-${mm}-${dd}`;
}
function formatDate(dateString) {
  const date = parseFlexibleDate(dateString); if (!date) return String(dateString);
  const dd = String(date.getUTCDate()).padStart(2,'0');
  const mm = String(date.getUTCMonth()+1).padStart(2,'0');
  const yyyy = date.getUTCFullYear();
  return `${dd}/${mm}/${yyyy}`;
}
function syncSelectValue(selectEl, value) {
  if (!selectEl || value == null) return;
  const val = String(value); let found = false;
  for (const opt of Array.from(selectEl.options)) {
    if (String(opt.value) === val || String(opt.textContent).trim() === val) { selectEl.value = opt.value; found = true; break; }
  }
  if (!found && val) { const opt = document.createElement('option'); opt.value = val; opt.textContent = val; selectEl.appendChild(opt); selectEl.value = val; }
}
function syncDateSelect(selectEl, dateRaw) {
  if (!selectEl || !dateRaw) return;
  if (selectEl.tagName === 'SELECT') {
    const display = formatDate(dateRaw); let found = false;
    for (const opt of Array.from(selectEl.options)) {
      if (opt.value === dateRaw || opt.textContent === display) { selectEl.value = opt.value; found = true; break; }
    }
    if (!found) { const opt = document.createElement('option'); opt.value = dateRaw; opt.textContent = display; selectEl.appendChild(opt); selectEl.value = dateRaw; }
  } else if (selectEl.type === 'date') selectEl.value = toDateInputValue(dateRaw);
}

/* ===================== Data Load ===================== */
async function loadContractorsFromNocoDB() {
  const { contractorsListEndpoint, nocodbToken } = CONFIG;
  if (!contractorsListEndpoint || !nocodbToken) { 
    console.warn('Contractors endpoint or token not configured.'); 
    return; 
  }

  try {
    const withLimit = contractorsListEndpoint.includes('limit=') ? contractorsListEndpoint : (contractorsListEndpoint + (contractorsListEndpoint.includes('?') ? '&' : '?') + 'limit=100');

    const response = await fetch(withLimit, {
      method: 'GET',
      headers: { 'accept': 'application/json', 'xc-token': nocodbToken }
    });

    if (!response.ok) {
      let bodyText = ''; try { bodyText = await response.text(); } catch {}
      throw new Error(`NocoDB HTTP ${response.status} ${response.statusText}${bodyText ? ` - ${bodyText.substring(0, 300)}` : ''}`);
    }

    const data = await response.json();
    const rows = Array.isArray(data) ? data : (data.list || []);

    if (!rows.length) {
      console.warn('No contractors found in NocoDB table.');
      return;
    }

    // Build contractor select
    const contractorSelect = document.getElementById('contractorName');
    contractorSelect.innerHTML = '<option value="">Choose a contractor...</option>';

    rows.forEach(row => {
      // Get contractor name using the field ID you provided
      const contractorName = getField(row, ['ckmc09y2aw0gkvx', 'Contractor Name', 'contractor_name', 'name', 'Name', 'title', 'Title']);
      
      if (contractorName) {
        const option = document.createElement('option');
        option.value = String(contractorName);
        option.textContent = String(contractorName);
        contractorSelect.appendChild(option);
        
        // Store the contractor row data for later use
        contractorRowsByName.set(String(contractorName), row);
      }
    });

    console.log(`Loaded ${rows.length} contractors from NocoDB`);
  } catch (error) {
    console.error('Error loading contractors from NocoDB:', error);
  }
}

async function loadSchedulesFromNocoDB() {
  const { schedulesListEndpoint, nocodbToken } = CONFIG;
  if (!schedulesListEndpoint || !nocodbToken) { showError('Please configure schedulesListEndpoint and API token first.'); return; }

  showLoading(true);
  clearMessages();

  try {
    const withLimit = schedulesListEndpoint.includes('limit=') ? schedulesListEndpoint : (schedulesListEndpoint + (schedulesListEndpoint.includes('?') ? '&' : '?') + 'limit=100');

    // Ensure Property, Followup, and Lawn Schedule links are expanded
    let urlObj; try { urlObj = new URL(withLimit); } catch { urlObj = null; }
    let url;
    if (urlObj) {
      const existing = urlObj.searchParams.get('expand');
      const needed = ['Property', 'Followup', 'Lawn Schedule'];
      const parts = new Set((existing ? existing.split(',') : []).map(s => s.trim()).filter(Boolean));
      needed.forEach(n => parts.add(n));
      urlObj.searchParams.set('expand', Array.from(parts).join(','));
      url = urlObj.toString();
    } else {
      const sep = withLimit.includes('?') ? '&' : '?';
      url = `${withLimit}${sep}expand=${encodeURIComponent('Property,Followup,Lawn Schedule')}`;
    }

    const response = await fetch(url, {
      method: 'GET',
      headers: { 'accept': 'application/json', 'xc-token': nocodbToken }
    });

    if (!response.ok) {
      let bodyText = ''; try { bodyText = await response.text(); } catch {}
      throw new Error(`NocoDB HTTP ${response.status} ${response.statusText}${bodyText ? ` - ${bodyText.substring(0, 300)}` : ''}`);
    }

    const data = await response.json();
    const rows = Array.isArray(data) ? data : (data.list || []);

    if (!rows.length) showError('NocoDB returned 0 records. Check table/view permissions or filters.');

    /* === FILTER: only available schedules (no contractor AND no status) === */
    const filteredRows = rows.filter(row => {
      const assigned = getField(row, ['Assigned Contractor','assigned contractor','Assigned_Contractor','assigned_contractor']);
      const status   = getField(row, ['Status','status']);
      return isBlank(assigned) && isBlank(status);
    });

    // Build schedule select and in-memory map
    scheduleRowsById = new Map();
    const scheduleSelect = document.getElementById('scheduleId');
    scheduleSelect.innerHTML = '<option value="">Choose a schedule...</option>';

    filteredRows.forEach(row => {
      // Use NocoDB's auto-generated primary key (Id) as the main identifier
      const internalRowId = row.Id != null ? row.Id : (row.id != null ? row.id : '');
      if (internalRowId == null || internalRowId === '') return;

      // Human-visible schedule identifier for display purposes
      const scheduleHumanId = getField(row, ['Schedule ID','Schedule_ID','schedule_id','ScheduleId','scheduleid']);

      // Key in-memory map by NocoDB internal row ID
      scheduleRowsById.set(String(internalRowId), row);

      const propertyId = getField(row, ['Property','property','Property_ID','property_id','PropertyId','propertyid']);
      const propertyDisplayRaw = resolvePropertyDisplay(row) || resolvePropertyName(row) || propertyId;
      const propertyDisplay = getDisplayString(propertyDisplayRaw);

      let serviceDateRaw = resolveAnyDate(row);
      const serviceType = getField(row, ['Service Type','service type','Service_Type','service_type','Service','service','service_name','servicename']);

      const summaryParts = [
        `ID: ${internalRowId}`,
        propertyDisplay ? `Prop: ${propertyDisplay}` : null,
        serviceDateRaw ? `Date: ${formatDate(serviceDateRaw)}` : `Date: N/A`,
        serviceType ? `Type: ${serviceType}` : null
      ].filter(Boolean);
      const summary = summaryParts.join(' | ');

      const opt = document.createElement('option');
      opt.value = String(internalRowId); // Use internal row ID as the value we save
      opt.textContent = summary;
      opt.dataset.rawDate = serviceDateRaw ? String(serviceDateRaw) : '';
      opt.dataset.propertyDisplay = propertyDisplay || '';
      opt.dataset.scheduleHumanId = scheduleHumanId || '';
      scheduleSelect.appendChild(opt);
    });

    // Keep form blank on load (no auto-selection)
    scheduleSelect.selectedIndex = 0;
    applyScheduleSelection('');

    // Populate properties, services, and dates sets (from filtered rows)
    const propertySet = new Set(); const serviceSet  = new Set(); const dateSet = new Set();

    filteredRows.forEach(row => {
      const propDisplayRaw = row.Property_Name || row.property_name || row.property || row.name ||
        resolvePropertyDisplay(row) || resolvePropertyName(row) ||
        getField(row, ['Property','property','Property_ID','property_id','PropertyId','propertyid']);
      const propDisplay = getDisplayString(propDisplayRaw);
      if (propDisplay) propertySet.add(propDisplay);

      const serviceName = row.Service || row.service || row.service_name ||
        getField(row, ['Service Type','service type','Service_Type','service_type','servicename']);
      if (serviceName) serviceSet.add(serviceName);

      const rawDate = row.Work_Date || row.upcoming_date || row.date || row.scheduled_date || row.booking_date ||
        getField(row, ['Schedule Service Date','Schedule Service Datem','Schedule_Service_Date','Service Date','service date','service_date']);
      if (rawDate) dateSet.add(rawDate);
    });

    populateFormData({
      properties: Array.from(propertySet).map(name => ({ id: name, name })),
      services:   Array.from(serviceSet).map(name => ({ id: name, name })),
      availableDates: Array.from(dateSet)
    });

    showSuccess('Form data loaded from NocoDB successfully!');
  } catch (error) {
    console.error('Error loading from NocoDB:', error);
    const msg = (error && error.message) ? error.message : String(error);
    if (msg.includes('Failed to fetch')) showError('Failed to reach NocoDB (network/CORS). Serve this page over HTTPS and enable CORS on NocoDB.');
    else showError('NocoDB error: ' + msg);
  } finally {
    showLoading(false);
  }
}

/* ===================== Apply selection ===================== */
function applyContractorSelection(contractorName) {
  const companyNameEl = document.getElementById('companyName');
  
  if (!contractorName) {
    companyNameEl.value = '';
    return;
  }
  
  const contractorRow = contractorRowsByName.get(String(contractorName));
  if (contractorRow) {
    // Get company name using the field ID you provided
    const companyName = getField(contractorRow, ['cmh9013o72ks4a4', 'Company Name', 'company_name', 'company', 'Company']);
    companyNameEl.value = companyName ? String(companyName) : '';
  } else {
    companyNameEl.value = '';
  }
}

function applyScheduleSelection(scheduleId) {
  const row = scheduleRowsById.get(String(scheduleId));
  const propertyIdEl = document.getElementById('propertyId');
  const serviceDateEl = document.getElementById('serviceDate');
  const serviceTypeEl = document.getElementById('serviceType');
  const assignedContractorEl = document.getElementById('assignedContractor');
  const scheduleSelect = document.getElementById('scheduleId');
  const selectedOpt = scheduleSelect ? scheduleSelect.options[scheduleSelect.selectedIndex] : null;

  if (!row) {
    propertyIdEl.value = '';
    serviceDateEl.value = '';
    serviceTypeEl.value = '';
    assignedContractorEl.value = '';
    return;
  }

  const propertyId = getField(row, ['Property','property','Property_ID','property_id','PropertyId','propertyid']);
  let propertyDisplayRaw = resolvePropertyDisplay(row) || resolvePropertyName(row);
  if (propertyDisplayRaw == null && selectedOpt) propertyDisplayRaw = selectedOpt.dataset.propertyDisplay;
  const propertyDisplay = getDisplayString(propertyDisplayRaw);

  let serviceDateRaw = resolveAnyDate(row);
  const effectiveRawDate = serviceDateRaw || (selectedOpt && selectedOpt.dataset.rawDate) || '';

  const serviceType = getField(row, ['Service Type','service type','Service_Type','service_type','Service','service','service_name','servicename']);
  const assigned = getField(row, ['Assigned Contractor','assigned contractor','Assigned_Contractor','assigned_contractor']);

  propertyIdEl.value = propertyId != null ? String(propertyId) : '';
  document.getElementById('propertyDisplay').value = propertyDisplay || '';
  serviceDateEl.value = effectiveRawDate ? toDateInputValue(effectiveRawDate) : '';
  // Also reflect date into the visible bookingDate input
  const bookingDateEl = document.getElementById('bookingDate');
  if (bookingDateEl && effectiveRawDate) bookingDateEl.value = toDateInputValue(effectiveRawDate);
  serviceTypeEl.value = serviceType != null ? String(serviceType) : '';
  assignedContractorEl.value = assigned != null ? String(assigned) : '';

  // Sync visible selects
  syncSelectValue(document.getElementById('property'), propertyDisplay || propertyId);
  syncSelectValue(document.getElementById('service'), serviceType);
  syncDateSelect(document.getElementById('bookingDate'), effectiveRawDate);
}

/* ===================== Populate visible form data ===================== */
function populateFormData(data) {
  const propertySelect = document.getElementById('property');
  propertySelect.innerHTML = '<option value="">Choose a property...</option>';
  if (data.properties) data.properties.forEach(property => {
    const option = document.createElement('option');
    option.value = property.id || property.name;
    option.textContent = property.name;
    propertySelect.appendChild(option);
  });

  const serviceSelect = document.getElementById('service');
  serviceSelect.innerHTML = '<option value="">Choose a service...</option>';
  if (data.services) data.services.forEach(service => {
    const option = document.createElement('option');
    option.value = service.id || service.name;
    option.textContent = service.name;
    serviceSelect.appendChild(option);
  });

  const dateEl = document.getElementById('bookingDate');
  if (data.availableDates || data.dates) {
    const dates = data.availableDates || data.dates;
    if (dateEl && dateEl.tagName === 'SELECT') {
      dateEl.innerHTML = '<option value="">Choose a date...</option>';
      dates.forEach(date => {
        const option = document.createElement('option');
        option.value = date;
        option.textContent = formatDate(date);
        dateEl.appendChild(option);
      });
    }
  }
}

/* ===================== Submit ===================== */
document.getElementById('bookingForm').addEventListener('submit', async function (e) {
  e.preventDefault();

  const { bookingsCreateEndpoint, nocodbToken, linkSchedule } = CONFIG;
  if (!bookingsCreateEndpoint || bookingsCreateEndpoint.includes('REPLACE_WITH_BOOKINGS_TABLE_ID')) {
    showError('Please set CONFIG.bookingsCreateEndpoint to your Bookings table records URL.');
    return;
  }

  // Explicit validation for required fields to avoid false negatives
  const requiredFields = [
    { id: 'contractorName', label: 'Contractor Name' },
    { id: 'property', label: 'Property' },
    { id: 'service', label: 'Service' },
    { id: 'bookingDate', label: 'Preferred Date' },
    { id: 'status', label: 'Status' }
  ];
  const missing = requiredFields.filter(f => {
    const el = document.getElementById(f.id);
    if (!el) return true;
    if (el.tagName === 'SELECT') return !el.value;
    if (el.type === 'date') return !el.value;
    return !(el.value && String(el.value).trim());
  });
  if (missing.length) {
    const labels = missing.map(m => m.label).join(', ');
    showError('Please fill required: ' + labels);
    return;
  }

  showLoading(true, 'Submitting booking...');
  clearMessages();

  const submitBtn = document.getElementById('submitBtn');
  submitBtn.disabled = true;
  submitBtn.textContent = '⏳ Submitting...';

     try {
     const formData = new FormData(this);
     const bookingData = {};
     
     // Map selected schedule using NocoDB's internal row ID
     const scheduleSelectEl = document.getElementById('scheduleId');
     const chosenInternalId = scheduleSelectEl ? scheduleSelectEl.value : (formData.get('scheduleId') || '');
     const chosenOpt = scheduleSelectEl && scheduleSelectEl.selectedIndex >= 0 ? scheduleSelectEl.options[scheduleSelectEl.selectedIndex] : null;
     const humanScheduleId = chosenOpt ? (chosenOpt.dataset.scheduleHumanId || '') : '';
     
                                                                  // Map form fields to NocoDB field IDs - use exact field IDs from your table
          const fieldMappings = {
            // Use exact field IDs from your NocoDB table
            'Property Address': formData.get('property') || '',
            'Service Type': formData.get('service') || '',
            'Booking Date': formData.get('bookingDate') || '',
            'Status': formData.get('status') || '',
            'Time Slot': formData.get('timeSlot') || '',
            
                                      // Use the exact field ID for Contractor Name
              'cmxls1m9i6n2ahf': formData.get('contractorName') || '',
             
             
             
             // Use the exact field ID for Notes
             'ca4bcpygr0tsvcs': formData.get('notes') || '',
            
                         // Use the exact field ID for Schedule Service Date
             'cdv3b2c1wlna8nz': document.getElementById('serviceDate')?.value || ''
          };
     
     // Copy mapped fields to bookingData
     Object.assign(bookingData, fieldMappings);
    
    // Ensure status is properly set (both uppercase and lowercase)
    if (bookingData.status) {
      bookingData.Status = bookingData.status;
    }

    

         // Normalize and ensure Status is set from the visible select if missing
     const statusSelect = document.getElementById('status');
     const selectedStatus = statusSelect ? statusSelect.value : '';
     if (!bookingData.Status && selectedStatus) {
       bookingData.Status = selectedStatus;
       bookingData.status = selectedStatus;
     }

     // Always send a PLAIN TEXT column to Bookings for auditing/reference
     // Make sure your Bookings table has a TEXT column named exactly "Lawn Schedule ID"
     if (chosenInternalId) {
       bookingData['Lawn Schedule ID'] = String(chosenInternalId); // <-- writeable text column in BOOKINGS
       // Optional convenience copies if you created these columns too:
       bookingData['Schedule ID'] = humanScheduleId || String(chosenInternalId);
     }

    // Add hidden/programmatic fields to ensure complete data capture
    const hiddenFields = {
      'propertyId': document.getElementById('propertyId')?.value || '',
      'propertyDisplay': document.getElementById('propertyDisplay')?.value || '',
      'serviceDate': document.getElementById('serviceDate')?.value || '',
      'serviceType': document.getElementById('serviceType')?.value || '',
      'assignedContractor': document.getElementById('assignedContractor')?.value || '',
      'statusSource': document.getElementById('statusSource')?.value || ''
    };
    
    // Merge hidden fields into bookingData
    Object.assign(bookingData, hiddenFields);

               console.log('Submitting to NocoDB:', bookingData);
      console.log('All form fields being sent:', Object.keys(bookingData));
      console.log('Form data entries:', Array.from(formData.entries()));
      console.log('Field mappings being used:', fieldMappings);
      
             // Debug: Show what's actually being sent
       console.log('=== DEBUG: Field Values ===');
              console.log('Contractor Name:', bookingData['Contractor Name'] || bookingData['contractorName']);

      console.log('Property:', bookingData['Property'] || bookingData['Property Address']);
      console.log('Service:', bookingData['Service'] || bookingData['Service Type'] || bookingData['Work Type']);
      console.log('Booking Date:', bookingData['Booking Date'] || bookingData['bookingDate']);
      console.log('Status:', bookingData['Status'] || bookingData['status']);
             console.log('Time Slot:', bookingData['Time Slot'] || bookingData['timeSlot']);
              console.log('Notes:', bookingData['Notes'] || bookingData['Additional Notes']);
               console.log('Service Date Value:', document.getElementById('serviceDate')?.value);
        console.log('Schedule Service Date (Field ID cdv3b2c1wlna8nz):', bookingData['cdv3b2c1wlna8nz']);
                 console.log('Contractor Name Value:', formData.get('contractorName'));
         console.log('Contractor Name (Field ID cmxls1m9i6n2ahf):', bookingData['cmxls1m9i6n2ahf']);
        console.log('Notes Value:', formData.get('notes'));
        console.log('Notes (Field ID ca4bcpygr0tsvcs):', bookingData['ca4bcpygr0tsvcs']);

    // Create row in NocoDB BOOKINGS table (authoritative store)
    let createdBooking = null;
    try {
      const ncCreate = await fetch(bookingsCreateEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'xc-token': nocodbToken
        },
        body: JSON.stringify(bookingData)
      });
      const createdText = await ncCreate.clone().text().catch(()=> '');
      console.log('NocoDB Response Status:', ncCreate.status);
      console.log('NocoDB Response Text:', createdText);
      
             if (!ncCreate.ok) {
         console.warn('NocoDB create failed:', ncCreate.status, createdText);
         console.error('Full NocoDB error response:', createdText);
         showError(`Failed to create booking in NocoDB: ${ncCreate.status} - ${createdText.substring(0, 200)}`);
         return;
       } else {
        createdBooking = await ncCreate.json().catch(()=>null);
        console.log('Successfully created booking:', createdBooking);
        console.log('Created booking ID:', createdBooking?.Id);
      }
    } catch (e) {
      console.warn('Error creating in NocoDB Bookings:', e);
    }

         // 3) OPTIONAL: if you actually have a Link column in Bookings -> Schedules, attach it via Links API
     if (linkSchedule && linkSchedule.enabled && createdBooking && createdBooking.Id && chosenInternalId) {
       try {
         const linkUrl = `https://nocodb-production-0a33.up.railway.app/api/v2/tables/${encodeURIComponent(linkSchedule.bookingsTableId)}/links/${encodeURIComponent(linkSchedule.linkFieldId)}/records/${encodeURIComponent(createdBooking.Id)}`;
         const linkResp = await fetch(linkUrl, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'Accept': 'application/json',
             'xc-token': nocodbToken
           },
           body: JSON.stringify({ Id: Number(chosenInternalId) })
         });
         const linkText = await linkResp.clone().text().catch(()=> '');
         if (!linkResp.ok) console.warn('Linking failed:', linkResp.status, linkText);
       } catch (e) {
         console.warn('Error during link attach:', e);
       }
     }

                 

               // 5) Create link to Contractor Profile table (One-to-Many: Contractor -> Bookings)
        if (createdBooking && createdBooking.Id && bookingData['cmxls1m9i6n2ahf']) {
          try {
            // First, find the contractor record ID from the contractor name
            const contractorName = bookingData['cmxls1m9i6n2ahf'];
            const contractorRow = contractorRowsByName.get(String(contractorName));
            
            if (contractorRow && contractorRow.Id) {
                             // For one-to-many relationship, we need to link from the "many" side (bookings) to the "one" side (contractor)
               // The link field should be in the bookings table pointing to the contractor table
               const contractorLinkUrl = `https://nocodb-production-0a33.up.railway.app/api/v2/tables/mjc7wycwsr6fo60/links/cej6y2chkxo8xce/records/${encodeURIComponent(createdBooking.Id)}`;
              
              console.log('Creating contractor link with:', {
                bookingId: createdBooking.Id,
                contractorId: contractorRow.Id,
                contractorName: contractorName,
                linkUrl: contractorLinkUrl
              });
              
              const linkResp = await fetch(contractorLinkUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
                  'xc-token': nocodbToken
                },
                body: JSON.stringify({ Id: Number(contractorRow.Id) })
              });
              
              const linkText = await linkResp.clone().text().catch(()=> '');
              console.log('Contractor link response:', linkResp.status, linkText);
              
              if (!linkResp.ok) {
                console.warn('Contractor Profile linking failed:', linkResp.status, linkText);
                // Try alternative approach - update the booking record directly with contractor ID
                try {
                  const updateUrl = `https://nocodb-production-0a33.up.railway.app/api/v2/tables/mjc7wycwsr6fo60/records/${encodeURIComponent(createdBooking.Id)}`;
                                     const updateData = {
                     'cej6y2chkxo8xce': Number(contractorRow.Id) // Direct field update
                   };
                  
                  const updateResp = await fetch(updateUrl, {
                    method: 'PATCH',
                    headers: {
                      'Content-Type': 'application/json',
                      'Accept': 'application/json',
                      'xc-token': nocodbToken
                    },
                    body: JSON.stringify(updateData)
                  });
                  
                  const updateText = await updateResp.clone().text().catch(()=> '');
                  if (!updateResp.ok) {
                    console.warn('Direct contractor field update failed:', updateResp.status, updateText);
                  } else {
                    console.log('Successfully updated booking with contractor ID directly');
                  }
                } catch (updateError) {
                  console.warn('Error during direct contractor field update:', updateError);
                }
              } else {
                console.log('Successfully linked booking to contractor profile via Links API');
              }
            } else {
              console.warn('Could not find contractor record ID for linking');
            }
          } catch (e) {
            console.warn('Error during contractor profile link:', e);
          }
        }

         showSuccess(`🎉 Booking created in NocoDB successfully! Status: ${bookingData.Status || 'N/A'}`);
     
     // Help user find the correct field names
     console.log('=== TO FIND CORRECT FIELD NAMES ===');
     console.log('1. Go to your NocoDB Bookings table');
     console.log('2. Look at the column headers');
     console.log('3. The exact field names should match what we\'re sending');
     console.log('4. If fields are missing, check the NocoDB error response above');

    // Explicitly clear all fields after successful submission
    try {
      this.reset();

                    // Clear hidden/programmatic fields
        const idsToClear = ['propertyId','propertyDisplay','serviceDate','serviceType','assignedContractor','statusSource'];
       idsToClear.forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });

      // Reset selects to placeholder option
      const selects = ['scheduleId','property','service','status','timeSlot','contractorName'];
      selects.forEach(id => { const el = document.getElementById(id); if (el && el.options && el.options.length) el.selectedIndex = 0; });

             // Ensure date input is blank
       const bookingDateEl = document.getElementById('bookingDate');
       if (bookingDateEl && bookingDateEl.type === 'date') bookingDateEl.value = '';
    } catch {}
  } catch (error) {
    console.error('Error submitting form:', error);
    if (String(error).includes('TypeError: Failed to fetch')) {
      showError('Submission failed: likely CORS or network issue. If using JSON/Authorization, enable CORS on server and allow OPTIONS.');
    } else {
      showError('Failed to submit booking: ' + (error && error.message ? error.message : String(error)));
    }
  } finally {
    showLoading(false);
    submitBtn.disabled = false;
    submitBtn.textContent = '📅 Submit Booking Request';
  }
});
</script>
</body>
</html>